#!/usr/bin/env bash
set -euo pipefail

DEB_DIR="${RECIPE_DIR}/../debs"
work="$(mktemp -d)"; trap 'rm -rf "$work"' EXIT
shopt -s nullglob
debs=( "$DEB_DIR"/*.deb )
(( ${#debs[@]} )) || { echo "[ERROR] no .deb in $DEB_DIR"; exit 1; }
for f in "${debs[@]}"; do dpkg-deb -x "$f" "$work"; done

# 统一 copy 函数（不依赖 rsync）
copy_tree(){ local src="$1" dst="$2"; mkdir -p "$dst"; (cd "$src" && tar -cf - .) | (cd "$dst" && tar -xf -); }

{% if kind in ['lib','bin','data'] %}
# 通用：把 usr/{bin,lib,include,share} 拷到 $PREFIX
[ -d "$work/usr/bin" ]     && copy_tree "$work/usr/bin"     "$PREFIX/bin"
[ -d "$work/usr/lib" ]     && copy_tree "$work/usr/lib"     "$PREFIX/lib"
[ -d "$work/usr/include" ] && copy_tree "$work/usr/include" "$PREFIX/include"
[ -d "$work/usr/share" ]   && copy_tree "$work/usr/share"   "$PREFIX/share"
{% endif %}

{% if kind == 'python_core' %}
# Python 主体 + stdlib + lib-dynload
PY="{{ pyver }}"
copy_tree "$work/usr/bin" "$PREFIX/bin"
[ -d "$work/usr/include" ] && copy_tree "$work/usr/include" "$PREFIX/include"
[ -d "$work/usr/lib/python$PY" ] && copy_tree "$work/usr/lib/python$PY" "$PREFIX/lib/python$PY"

# 兼容多架构路径：/usr/lib/*-linux-gnu/python$PY 与其中的 lib-dynload
arch_py_dir="$(find "$work/usr/lib" -maxdepth 2 -type d -path "*/lib/*-linux-gnu/python$PY" | head -n1 || true)"
if [ -n "$arch_py_dir" ]; then
  copy_tree "$arch_py_dir" "$PREFIX/lib/python$PY"
fi

# 保证存在一个最小的 sitecustomize.py，conda 创建环境时会引用该文件
mkdir -p "$PREFIX/lib/python$PY" "$PREFIX/lib/python$PY/lib-dynload"
if [ ! -f "$PREFIX/lib/python$PY/sitecustomize.py" ]; then
  install -m 0644 -D /dev/null "$PREFIX/lib/python$PY/sitecustomize.py"
  cat > "$PREFIX/lib/python$PY/sitecustomize.py" <<'PYSC'
# Minimal sitecustomize for deb2conda-wrapped Python.
# Intentionally empty to satisfy conda environment initialization.
PYSC
fi
# 确保 _ssl/_hashlib
dyn="$PREFIX/lib/python$PY/lib-dynload"
mkdir -p "$dyn"
for m in _ssl _hashlib; do
  if ! ls "$dyn/${m}.cpython-{{ pyabi }}-*.so" >/dev/null 2>&1; then
    # 优先标准路径
    so="$(find "$work" -type f -path "*/lib/python$PY/lib-dynload/${m}.cpython-{{ pyabi }}-*.so" | head -n1 || true)"
    # 兼容多架构路径 /usr/lib/*-linux-gnu/python$PY/
    if [ -z "$so" ]; then
      so="$(find "$work" -type f -path "*/lib/*-linux-gnu/python$PY/${m}.cpython-{{ pyabi }}-*.so" | head -n1 || true)"
    fi
    # 放宽匹配（某些发行版命名差异）
    if [ -z "$so" ]; then
      so="$(find "$work" -type f -name "${m}.cpython-*.so" | head -n1 || true)"
    fi
    if [ -z "$so" ]; then
      so="$(find "$work" -type f -name "${m}*.so" | head -n1 || true)"
    fi
    [ -n "$so" ] && install -m 0755 -D "$so" "$dyn/$(basename "$so")" || { echo "[ERROR] missing $m"; find "$work" -type f -name "${m}*" | head -n 50; exit 1; }
  fi
done

{% endif %}

{% if kind == 'python_ext' %}
# Python 扩展（numpy / python-tk 等）
PY="{{ pyver }}"
SP="$PREFIX/lib/python$PY/site-packages"
DY="$PREFIX/lib/python$PY/lib-dynload"
mkdir -p "$SP" "$DY"

# 复制 site-packages（版本专属路径）
if d="$(find "$work" -type d -path "*/lib/python$PY/site-packages" | head -n1)"; then
  copy_tree "$d" "$SP"
fi

# 兼容 Debian 的 /usr/lib/python3/dist-packages：将内容整体拷入 site-packages
if d3="$(find "$work" -type d -path "*/lib/python3/dist-packages" | head -n1)"; then
  copy_tree "$d3" "$SP"
fi

# 兼容 /usr/lib/python$PY/dist-packages：将内容整体拷入 site-packages
if d4="$(find "$work" -type d -path "*/lib/python$PY/dist-packages" | head -n1)"; then
  copy_tree "$d4" "$SP"
fi

# 兜底：若上面未命中，直接查找任何 pythonX.Y 的 (site|dist)-packages/scipy 并复制其上级目录
if ! ls "$SP/scipy" >/dev/null 2>&1; then
  while IFS= read -r pkgdir; do
    copy_tree "$pkgdir" "$SP"
  done < <(find "$work" -type d -regex ".*/lib/python[0-9]+\.[0-9]+/(site|dist)-packages/scipy" -print 2>/dev/null | sed 's|/scipy$||' | sort -u)
fi

# 若仍被放进了错误版本的 pythonX.Y 目录，重定位到目标 $PY 目录（含元数据目录）
for d in $(find "$PREFIX/lib" -maxdepth 3 -type d -regex ".*/lib/python[0-9]+\.[0-9]+/(site|dist)-packages" 2>/dev/null | grep -v "/python$PY/"); do
  # 主包目录
  if [ -d "$d/scipy" ]; then
    copy_tree "$d/scipy" "$SP/scipy"
    rm -rf "$d/scipy"
  fi
  # 相关的 dist-info/egg-info 元数据目录（多版本共存时关键）
  for meta in "$d"/scipy-*.dist-info "$d"/scipy-*.egg-info "$d"/scipy.dist-info "$d"/scipy.egg-info; do
    [ -e "$meta" ] || continue
    base="$(basename "$meta")"
    mkdir -p "$SP/$base"
    copy_tree "$meta" "$SP/$base"
    rm -rf "$meta"
  done
done

# 复制 lib-dynload/*.so（如 _tkinter）
for so in $(find "$work" -type f -path "*/lib/python$PY/lib-dynload/*.so" 2>/dev/null || true); do
  install -m 0755 -D "$so" "$DY/$(basename "$so")"
done

# 兼容部分发行版的 dist-packages/<pkg> 直挂目录
if d2="$(find "$work" -type d -path "*/dist-packages/*" | head -n1)"; then
  copy_tree "$(dirname "$d2")" "$SP"
fi
{% endif %}

# 软链（openblas 提供兼容 BLAS/LAPACK）
{% if extras.blas_alias %}( cd "$PREFIX/lib"; [ -f libopenblas.so.0 ] && ln -sf libopenblas.so.0 libblas.so.3; ){% endif %}
{% if extras.lapack_alias %}( cd "$PREFIX/lib"; [ -f libopenblas.so.0 ] && ln -sf libopenblas.so.0 liblapack.so.3; ){% endif %}

# 清理：移除属于其他包的 SONAME，避免与独立包发生 clobber（例如 libgfortran）。
{% for dso, mapped in map_run_deps.items() %}
if [ "{{ mapped.split(' ')[0] }}" != "{{ name }}" ]; then
  rm -f "$PREFIX/lib/{{ dso }}" "$PREFIX/lib"/{{ dso }}.* 2>/dev/null || true
  for archdir in "$PREFIX/lib"/*-linux-gnu; do
    [ -d "$archdir" ] || continue
    rm -f "$archdir/{{ dso }}" "$archdir"/{{ dso }}.* 2>/dev/null || true
  done
fi
{% endfor %}

# activate：最小化修改，仅导出 $CONDA_PREFIX/lib 到 LD_LIBRARY_PATH
mkdir -p "$PREFIX/etc/conda/activate.d" "$PREFIX/etc/conda/deactivate.d"
cat > "$PREFIX/etc/conda/activate.d/{{ name }}_activate.sh" <<'ACT'
if [ "${LD_LIBRARY_PATH+x}" = x ]; then export _OLD_LD_LIBRARY_PATH="$LD_LIBRARY_PATH"; fi
case ":${LD_LIBRARY_PATH:-}:" in *":$CONDA_PREFIX/lib:"*) : ;; *) export LD_LIBRARY_PATH="$CONDA_PREFIX/lib${LD_LIBRARY_PATH:+:$LD_LIBRARY_PATH}";; esac
ACT
cat > "$PREFIX/etc/conda/deactivate.d/{{ name }}_deactivate.sh" <<'DEACT'
if [ "${_OLD_LD_LIBRARY_PATH+x}" = x ]; then export LD_LIBRARY_PATH="$_OLD_LD_LIBRARY_PATH"; else unset LD_LIBRARY_PATH; fi
unset _OLD_LD_LIBRARY_PATH
DEACT
chmod +x "$PREFIX"/etc/conda/{activate.d,deactivate.d}/*

echo "[INFO] {{ name }} done."


