#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Generate conda-build recipes from Debian package manifest/rules.

Usage:
  python tools/debwrap.py gen --manifest manifest.yaml --rules rules.yaml

Outputs per package under workspace/recipes/<name>/:
  - debs/           (put matching .deb files here)
  - recipes/
      - meta.yaml
      - build.sh
"""

import argparse
import os
import re
import sys
import shutil
from pathlib import Path
from typing import Any, Dict, List, Tuple, Optional

try:
    import yaml  # type: ignore
except Exception as exc:  # pragma: no cover
    print("[ERROR] Missing dependency pyyaml. pip install pyyaml", file=sys.stderr)
    raise

try:
    from jinja2 import Environment, FileSystemLoader  # type: ignore
except Exception as exc:  # pragma: no cover
    print("[ERROR] Missing dependency jinja2. pip install jinja2", file=sys.stderr)
    raise

#假设脚本在 repo/tools/debwrap.py，则 REPO_ROOT = repo/。
REPO_ROOT = Path(__file__).resolve().parents[1]
TEMPLATES_DIR = REPO_ROOT / "templates"
WORKSPACE_DIR = REPO_ROOT / "workspace" / "recipes"

#读取 YAML 并返回字典；or {} 保险空文件时不崩。 示例：manifest = read_yaml(Path("manifest.yaml"))
def read_yaml(path: Path) -> Dict[str, Any]:
    with path.open("r", encoding="utf-8") as f:
        return yaml.safe_load(f) or {}

#确保目录存在；示例：ensure_dir(Path("workspace/recipes")) 递归建目录，若已存在不报错
def ensure_dir(path: Path) -> None:
    path.mkdir(parents=True, exist_ok=True)

#从 manifest 推断 Python 版本/ABI
#packages:
#  - name: python
#    kind: python_core
#    debs:
#      - python3.11-minimal
#      - python3.11-dev
#则返回 ("3.11", "311")。如果写：
#extras: { pyver: "3.10", pyabi: "310" }

#则返回被覆盖的 ("3.10", "310")。
def detect_python_version_from_manifest(manifest: Dict[str, Any]) -> Tuple[str, str]:
    """Detect python version (e.g. 3.12) and abi (e.g. 312) from the python core entry.
    Fallback to 3.12/312 if not detectable.
    """
    packages: List[Dict[str, Any]] = manifest.get("packages", []) or []
    pyver = "3.12"
    pyabi = "312"
    for entry in packages:
        if entry.get("kind") == "python_core":
            # Try to parse from deb patterns like python3.12-*
            debs: List[str] = entry.get("debs", []) or []
            joined = " ".join(debs)
            m = re.search(r"python3\.(\d+)", joined)
            if m:
                minor = m.group(1)
                pyver = f"3.{minor}"
                pyabi = f"3{minor}"
            # Allow explicit override via extras
            extras = entry.get("extras", {}) or {}
            if isinstance(extras.get("pyver"), str):
                pyver = extras["pyver"]
            if isinstance(extras.get("pyabi"), str):
                pyabi = extras["pyabi"]
            break
    return pyver, pyabi

# manifest.yaml 中的某个包
#extras:
#  needs: [ "numpy >=1.26", "scipy" ]

# rules.yaml
#python_site_requires:
#  myext: [ "cython", "numpy" ]
#对 name: myext 来说，最终 run_deps = ["numpy >=1.26", "scipy", "cython", "numpy"] 去重后
# ["numpy >=1.26", "scipy", "cython", "numpy"]（注意去重保序，会保留第一个 "numpy >=1.26"，
#后续的 "numpy" 与之不同，会一起保留——如果想更智能合并版本约束，可以在这里加规则）。

def compute_run_deps(pkg: Dict[str, Any], rules: Dict[str, Any]) -> List[str]:
    run_deps: List[str] = []

    # Allow extras.needs to directly specify run deps
    extras = pkg.get("extras", {}) or {}
    needs = extras.get("needs", []) or []
    if isinstance(needs, list):
        run_deps.extend([str(x) for x in needs])

    # If python_ext, consider python_site_requires overrides by package name
    if pkg.get("kind") == "python_ext":
        site_requires = rules.get("python_site_requires", {}) or {}
        reqs = site_requires.get(pkg.get("name"), []) or []
        run_deps.extend([str(x) for x in reqs])

    # Dedupe while keeping order
    seen = set()
    unique: List[str] = []
    for r in run_deps:
        if r not in seen:
            unique.append(r)
            seen.add(r)
    return unique

# manifest
#extras:
#  ensure_modules: [ "cv2", "numpy" ]

# rules
#test_snippets:
#  import_only: "python -c \"import {module}\""
#则生成两条命令：

#python -c "import cv2"

#python -c "import numpy"
def compute_test_cmds(pkg: Dict[str, Any], rules: Dict[str, Any]) -> List[str]:
    cmds: List[str] = []
    snippets = rules.get("test_snippets", {}) or {}

    # If extras.ensure_modules present, create import tests per module
    extras = pkg.get("extras", {}) or {}
    ensure_modules = extras.get("ensure_modules", []) or []
    if ensure_modules:
        tmpl = snippets.get("import_only", "python -c \"import {module}; print('OK')\"")
        for m in ensure_modules:
            cmds.append(tmpl.replace("{module}", str(m)))
        # For plain libraries, verify key DSOs exist in $PREFIX/lib using map_run_deps inversion

    kind = pkg.get("kind", "")
    if kind in {"lib", "bin", "data"}:
        map_run_deps: Dict[str, str] = rules.get("map_run_deps", {}) or {}
        provides: List[str] = []
        this_name = str(pkg.get("name"))
        for dso, mapped in map_run_deps.items():
            # value may include version constraints, only compare the package token
            mapped_name = str(mapped).split()[0]
            if mapped_name == this_name:
                provides.append(dso)
        for dso in provides:
            # Ensure the SONAME file exists after installation
            cmds.append(f"bash -c 'test -e \"$PREFIX/lib/{dso}\"'")

    # Fallback minimal test
    if not cmds and pkg.get("kind", "") in {"python_core", "python_ext"}:
        cmds.append("python -V")

    return cmds

#作用：从 extras.version 读取版本；若为空则默认 "0"（占位，避免模板无版本）。

#示例：extras: { version: "1.2.3" } → 返回 "1.2.3"。
def compute_version(pkg: Dict[str, Any]) -> str:
    # Version may be derived from deb, but we don't extract .deb here.
    # Accept explicit `version` in manifest extras; else default to 0.
    extras = pkg.get("extras", {}) or {}
    if isinstance(extras.get("version"), str) and extras["version"].strip():
        return extras["version"].strip()
    return "0"

#整理模板上下文（名字、版本、依赖、测试命令、Python 版本/ABI 等）；

#用 templates/meta.yaml.j2 与 templates/build.sh.j2 渲染；

#写到 <out_dir>/meta.yaml 与 build.sh，并给 build.sh 加可执行权限。
def render_templates(pkg: Dict[str, Any], rules: Dict[str, Any], pyver: str, pyabi: str, env: Environment, out_dir: Path) -> None:
    name = pkg["name"]
    version = compute_version(pkg)
    build_number = int(pkg.get("build_number", 0))
    kind = pkg.get("kind", "lib")

    run_deps = compute_run_deps(pkg, rules)
    test_cmds = compute_test_cmds(pkg, rules)

    summary = f"Wrapped from Debian packages: {', '.join(pkg.get('debs', []) or [])}"
    context: Dict[str, Any] = {
        "name": name,
        "version": version,
        "build_number": build_number,
        "kind": kind,
        "run_deps": run_deps,
        "test_cmds": test_cmds,
        "summary": summary,
        "missing_dso": pkg.get("missing_dso", []) or [],
        "extras": pkg.get("extras", {}) or {},
        "pyver": pyver,
        "pyabi": pyabi,
    }

    # meta.yaml
    meta_t = env.get_template("meta.yaml.j2")
    meta_out = meta_t.render(**context)
    (out_dir / "meta.yaml").write_text(meta_out, encoding="utf-8")

    # build.sh
        # build.sh: choose a simpler template for plain libs to avoid Jinja control tags
    if kind in {"lib", "bin", "data"}:
        build_t = env.get_template("build.lib.sh.j2")
    else:
        build_t = env.get_template("build.sh.j2")

    build_out = build_t.render(**context)
    build_path = out_dir / "build.sh"
    build_path.write_text(build_out, encoding="utf-8")
    os.chmod(build_path, 0o755)

#作用：
#读取配置；创建 Jinja 环境；遍历 packages；
#为每个包创建 debs/ 和 recipes/ 目录；
#调用 render_templates() 生成文件；
#打印结果。
#示例：对于 name: opencv-python，会创建
def _copy_matching_debs(deb_src: Path, patterns: List[str], dest_dir: Path) -> int:
    """Copy .deb files from deb_src matching any of patterns into dest_dir.
    Returns number of files copied.
    """
    copied = 0
    for pat in patterns:
        # Use Path.glob relative to deb_src
        for match in deb_src.glob(pat):
            if match.is_file():
                target = dest_dir / match.name
                shutil.copy2(match, target)
                print(f"[COPY] {match} -> {target}")
                copied += 1
    if copied == 0:
        pats = ", ".join(patterns) if patterns else "<none>"
        print(f"[WARN] No .deb matched in {deb_src} for patterns: {pats}")
    return copied


def cmd_gen(manifest_path: Path, rules_path: Path, deb_src: Optional[Path] = None) -> None:
    manifest = read_yaml(manifest_path)
    rules = read_yaml(rules_path)

    pyver, pyabi = detect_python_version_from_manifest(manifest)

        # Use custom comment delimiters to avoid accidental parsing issues in shell scripts
    env = Environment(
        loader=FileSystemLoader(str(TEMPLATES_DIR)),
        autoescape=False,
        trim_blocks=True,
        lstrip_blocks=True,
        comment_start_string="##~",
        comment_end_string="~##",
    )

    pkgs: List[Dict[str, Any]] = manifest.get("packages", []) or []
    if not pkgs:
        print("[WARN] No packages found in manifest.")

    for pkg in pkgs:
        name = pkg.get("name")
        if not name:
            print("[WARN] Skip entry without name")
            continue

        base_dir = WORKSPACE_DIR / name
        debs_dir = base_dir / "debs"
        recipes_dir = base_dir / "recipes"
        ensure_dir(debs_dir)
        ensure_dir(recipes_dir)

        # Optionally copy .deb files from a source directory into per-package debs/
        if deb_src is not None:
            if not deb_src.exists() or not deb_src.is_dir():
                print(f"[ERROR] --deb-src path not a directory: {deb_src}")
            else:
                patterns: List[str] = [str(x) for x in (pkg.get("debs", []) or [])]
                _copy_matching_debs(deb_src, patterns, debs_dir)

        render_templates(pkg, rules, pyver, pyabi, env, recipes_dir)
        print(f"[OK] Generated recipe for {name} -> {recipes_dir}")

#作用：定义 gen 子命令及其参数；路由到 cmd_gen。

#示例：

#python tools/debwrap.py gen --manifest manifest.yaml --rules rules.yaml
def main() -> None:
    parser = argparse.ArgumentParser(prog="debwrap", description="Generate conda recipes from Debian packages")
    sub = parser.add_subparsers(dest="cmd", required=True)

    p_gen = sub.add_parser("gen", help="Generate recipes")
    p_gen.add_argument("--manifest", required=True, type=Path)
    p_gen.add_argument("--rules", required=True, type=Path)
    p_gen.add_argument("--deb-src", required=False, type=Path, help="Directory containing source .deb files to copy from")

    args = parser.parse_args()

    if args.cmd == "gen":
        cmd_gen(args.manifest, args.rules, args.deb_src)
    else:  # pragma: no cover
        parser.error("unknown command")


if __name__ == "__main__":
    main()

